package fpinscala.monoids

//import fpinscala.parallelism.Nonblocking._
//import fpinscala.parallelism.Nonblocking.Par.toParOps // infix syntax for `Par.map`, `Par.flatMap`, etc
import language.higherKinds

trait Monoid[A] {
  def op(a1: A, a2: A): A
  def zero: A
}

object Monoid {

  val stringMonoid = new Monoid[String] {
    def op(a1: String, a2: String) = a1 + a2
    val zero = ""
  }

  def listMonoid[A] = new Monoid[List[A]] {
    def op(a1: List[A], a2: List[A]) = a1 ++ a2
    val zero = Nil
  }

  val intAddition = new Monoid[Int] {
    def op(a1: Int, a2: Int) = a1 + a2
    val zero = 0
  }

  val intMultiplication = new Monoid[Int] {
    def op(a1: Int, a2: Int) = a1 * a2
    val zero = 1
  }

  val booleanOr = new Monoid[Boolean] {
    def op(a1: Boolean, a2: Boolean) = a1 || a2
    val zero = false
  }

  val booleanAnd = new Monoid[Boolean] {
    def op(a1: Boolean, a2: Boolean) = a1 && a2
    val zero = true
  }

  // I don't see how this can be done without specifying a Monoid for A, so I'm adding it
  def optionMonoid[A](m: Monoid[A]) = new Monoid[Option[A]] {
    def op(a1: Option[A], a2: Option[A]) =
      (a1, a2) match {
        case (None, o) =>
          o
        case (o, None) =>
          o
        case (Some(av1), Some(av2)) =>
          Some(m.op(av1, av2))
      }
    val zero = None
  }

  def endoMonoid[A]: Monoid[A => A]  = new Monoid[A => A] {
    def op(a1: A => A, a2: A => A) =
      // apply each in succession
      (a: A) => a1(a2(a))

    val zero =
      // plain old identify function
      (a: A) => a
  }



  def aTriple[A](gen: Gen[A]): Gen[(A, A, A)] = {
    Gen.listOfN(3, gen).map { list =>
      val seq = list.toSeq
      (seq(0), seq(1), seq(2))
    }
  }

  def monoidLaws[A](m: Monoid[A], gen: Gen[A]): Prop =
    Prop.forAll(gen)(a => m.op(a, m.zero) == a) &&
    Prop.forAll(gen)(a => m.op(m.zero, a) == a) &&
    Prop.forAll(gen)(a => m.op(m.zero, m.zero) == m.zero) &&
    Prop.forAll(aTriple(gen))(t => m.op(m.op(t._1, t._2), t._3) == m.op(m.op(t._1, t._2), t._3))



  // what are these doing here?
  def trimMonoid(s: String): Monoid[String] = sys.error("todo")
  def concatenate[A](as: List[A], m: Monoid[A]): A =
    sys.error("todo")


  def foldMap[A, B](as: List[A], m: Monoid[B])(f: A => B): B =
    as.foldLeft(m.zero){(acc,a) => m.op(acc, f(a))}

  def foldMapWithFoldRight[A, B](as: List[A], m: Monoid[B])(f: A => B): B =
    // careful of the order here
    as.foldRight(m.zero){(a, acc) => m.op(f(a), acc)}


//  def foldRight[A, B](as: List[A])(z: B)(f: (A, B) => B): B = {
//    def toB(a: A) = f(a, z) // no, that's not right, that will put 'z' between every pair of a's; 'z' isn't zero, it's the starting value
//    val m = new Monoid[B] {
//      def op(b1: B, b2: B) = f(as.head, b2)
//      val zero = z
//    }
//    foldMap(as, m)(toB)
//  }
// from the answers:
//  // The function type `(A, B) => B`, when curried, is `A => (B => B)`.
//  // And of course, `B => B` is a monoid for any `B` (via function composition).
  def foldRight[A, B](as: List[A])(z: B)(f: (A, B) => B): B =
    foldMap(as, endoMonoid[B])(f.curried)(z)
// oh!!!  I was kinda of on the right track when I thought Monoid[(A,B)], i.e. it had to be
//  more than [B], and I was wondering if somehow the A might create each function... anyway,
//  the trick was we needed Monoid[B=>B]... i.e. endoMonoid... so build up a series of B=>B
//  functions, each generated by a particular value of A, then string them together
// I don't like their explanation, they could have first should the long way of doing B=>B
//  and then shortened it; simply saying "when curried" jumps over a lot of steps
//
// also, note it's all about building up big datastructures of FUNCTIONS, not of values, in the fold,
//  that seems to be the biggest lesson of this book, it's all about building giant functions that
//  sit about in memory waiting to be executed

  def foldLeft[A, B](as: List[A])(z: B)(f: (B, A) => B): B = {
    def curried(a: A) = (b: B) => f(b,a) // have to curry it ourselves, Function.curried only pulls out first param
    foldMap(as, endoMonoid[B])(curried)(z)
  }

  def foldMapV[A, B](as: IndexedSeq[A], m: Monoid[B])(f: A => B): B =
    as.size match {
      case 0 =>
        m.zero
      case 1 =>
        f(as.head)
      case n =>
        val (left, right) = as.splitAt(n/2)
        m.op(foldMapV(left, m)(f), foldMapV(right, m)(f))
    }


  // one way to track if sorted is to encoded whether a seq is "sorted" with an Option;
  //  after that, we really only care about the range of the sequence, not the interim values;
  //  then we can tell if two ranges are ordered just by looking at the left max and the right min,
  //  then the left min and right max become the new range
  val orderedMonoid = new Monoid[Option[(Int,Int)]] {
    def op(a1: Option[(Int, Int)], a2: Option[(Int, Int)]) =
      (a1, a2) match {
        case (`zero`, x) =>
          x
        case (x, `zero`) =>
          x
        case (Some(left), Some(right)) if (left._2 <= right._1) =>
          Some((left._1, right._2))
        case _ =>
          None
      }
    // this seems to be the only pair of values which is easily identifiable, and which
    //  won't ever interfere with a real range
    val zero = Some((Int.MinValue, Int.MaxValue))
  }

  def ordered(ints: IndexedSeq[Int]): Boolean = {
    def f(a: Int) = Some((a,a))
    foldMapV(ints, orderedMonoid)(f).isDefined
  }

  sealed trait WC
  case class Stub(chars: String) extends WC
  case class Part(lStub: String, words: Int, rStub: String) extends WC

//  def par[A](m: Monoid[A]): Monoid[Par[A]] =
//    sys.error("todo")
//
//  def parFoldMap[A,B](v: IndexedSeq[A], m: Monoid[B])(f: A => B): Par[B] =
//    sys.error("todo")

  // this one was particularly weakly specified... how are Stubs combined?
  //  how does the parsing happen?  I suppose this will come up in the next
  //  exercise when 'count' is built...
  // And ... this seems wrong.  It works, but it's way too convoluted. It
  //  hardly seems to be a good case for using Monoids.
  val wcMonoid: Monoid[WC] = new Monoid[WC] {
    def op(a1: WC, a2: WC): WC =
      (a1,a2) match {
        // it's suspicious that these cases should have to be caught explicitly
        case (`zero`, x) =>
          x
        case (x, `zero`) =>
          x

        // these next two are critical, they properly consume spaces
        case (Stub(a), Stub(" ")) =>
          Part(a, 0, "")
        case (Stub(" "), Stub(b)) =>
          Part("", 0, b)

        // don't know if we have a word, yet, so stay a Stub
        case (Stub(a), Stub(b)) =>
          Stub(a + b)

        case (Stub(a), Part(left, count, right)) =>
          if(a == " ")
            if(left == "")
              Part(left, count, right)
            else
              Part("", count + 1, right)
          else
            if(left == "")
              Part(a, count, right)
            else
              Part(a + left, count, right)

        case (Part(left, count, right), Stub(b)) =>
          if(b == " ")
            if(right == "")
              Part(left, count, right)
            else
              Part(left, count + 1, "")
          else
            if(right == "")
              Part(left, count, b)
            else
              Part(left, count, right + b)

        case (Part(left1, count1, right1), Part(left2, count2, right2)) =>
          val middleWordCount = if((right1 + left2).size > 0) 1 else 0
          Part(left1, count1 + count2 + middleWordCount, right2)
      }
    val zero: WC = Part("", 0, "")
  }

  def stringToWc(s: String): WC = {
    s.size match {
      case 0 =>
        wcMonoid.zero
      case 1 =>
        // can't remove spaces, here, as we don't know what they mean; do it in the op() function
        Stub(s)
      case n =>
        val left = stringToWc(s.substring(0, n/2))
        val right = stringToWc(s.substring(n/2))
//        println(s"$s => '$left' / '$right'")
        wcMonoid.op(left, right)
    }
  }

  // looking at the answer, it's complicated too, but somewhat simpler with
  //  a simpler 'zero'... let's try to implement
  val wcMonoid2: Monoid[WC] = new Monoid[WC] {
    def op(a1: WC, a2: WC): WC =
      (a1,a2) match {
        case (Stub(a), Stub(b)) =>
          Stub(a + b)

        case (Stub(a), Part(left, count, right)) =>
          Part(a + left, count, right)

        case (Part(left, count, right), Stub(b)) =>
          Part(left, count, right + b)

        case (Part(left1, count1, right1), Part(left2, count2, right2)) =>
          val middleWordCount = if((right1 + left2).size > 0) 1 else 0
          Part(left1, count1 + count2 + middleWordCount, right2)
      }
    val zero: WC = Stub("")
  }

  // using the answer's monoid
  def stringToWc2(s: String): WC = {
    s.size match {
      case 0 =>
        wcMonoid2.zero
      case 1 =>
        if(s == " ")
          // ah, clever, creating an empty Part is what separates the words on either side,
          //  which is a better meaning for the empty Part, rather than being 'zero' in my solution
          Part("", 0, "")
        else
          Stub(s)
      case n =>
        val left = stringToWc(s.substring(0, n/2))
        val right = stringToWc(s.substring(n/2))
        //        println(s"$s => '$left' / '$right'")
        wcMonoid2.op(left, right)
    }
  }

  // this works with either my Monoid or the answer's Monoid, just change 'stringToWc' appropriately
  def count(s: String): Int =
    stringToWc(s) match {
      case Stub(c) =>
//        println("stub " + s)
        if(c.size == 0)
          0
        else
          1
      case Part(left, count, right) =>
        val leftCount = if(left.size > 0) 1 else 0
        val rightCount = if(right.size > 0) 1 else 0
//        println((s, left, count, right, leftCount, rightCount, count + leftCount + rightCount))
        count + leftCount + rightCount
    }


  def productMonoid[A,B](A: Monoid[A], B: Monoid[B]): Monoid[(A, B)] =
    new Monoid[(A, B)] {
      def op(a1: (A, B), a2: (A, B)): (A, B) = (A.op(a1._1, a2._1), B.op(a1._2, a2._2))
      def zero: (A, B) = (A.zero, B.zero)
    }

  def functionMonoid[A,B](B: Monoid[B]): Monoid[A => B] =
    new Monoid[A => B] {
      def op(a1: A => B, a2: A => B): A => B =
        (a: A) => B.op(a1(a), a2(a))
      def zero: A => B =
        (a: A) => B.zero
    }

  def mapMergeMonoid[K,V](V: Monoid[V]): Monoid[Map[K, V]] =
    new Monoid[Map[K, V]] {
      def zero = Map[K,V]()
      def op(a: Map[K, V], b: Map[K, V]) =
        (a.keySet ++ b.keySet).foldLeft(zero) { (acc,k) =>
          acc.updated(k, V.op(a.getOrElse(k, V.zero),
            b.getOrElse(k, V.zero)))
        }
    }

  def bag[A](as: IndexedSeq[A]): Map[A, Int] = {
    // turn each word into a trivial wordcount map, then mash them all together adding the counts
    foldMapV(as, mapMergeMonoid[A,Int](intAddition)){ a: A => Map(a -> 1) }
  }
}
